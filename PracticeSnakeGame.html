<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Improved Snake Game</title>
  <style>
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif; text-align: center; background: #f7fff7; }
    #game-wrapper { display: inline-block; margin-top: 20px; }
    canvas { background: #fff; border: 4px solid #222; display: block; }
    .controls { margin-top: 10px; }
    button { margin: 0 6px; padding: 8px 12px; font-size: 14px; }
    .info { margin-top: 8px; }
  </style>
</head>
<body>
  <h1>Snake — Improved</h1>
  <div id="game-wrapper">
    <canvas id="game" width="400" height="400"></canvas>
    <div class="controls">
      <button id="startBtn">Start</button>
      <button id="pauseBtn">Pause</button>
      <button id="restartBtn">Restart</button>
    </div>
    <div class="info">
      <span id="score">Score: 0</span>
      &nbsp;•&nbsp;
      <span id="high">High: 0</span>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const restartBtn = document.getElementById('restartBtn');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('high');

    const CELL = 20; // cell size in px
    const COLS = canvas.width / CELL;
    const ROWS = canvas.height / CELL;

    let snake = [];
    let dir = { x: 1, y: 0 }; // current direction
    let nextDir = { x: 1, y: 0 }; // queued direction (prevents reversing)
    let food = null;
    let running = false;
    let paused = false;
    let score = 0;
    let high = parseInt(localStorage.getItem('snake_high')||'0', 10);
    highEl.textContent = 'High: ' + high;

    // Timing
    let lastTime = 0;
    const speed = 8; // moves per second
    const step = 1 / speed;
    let accumulator = 0;

    function init() {
      snake = [];
      const startLen = 5;
      const startX = Math.floor(COLS/2);
      const startY = Math.floor(ROWS/2);
      for (let i = 0; i < startLen; i++) {
        snake.push({ x: startX - i, y: startY });
      }
      dir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
      score = 0;
      scoreEl.textContent = 'Score: ' + score;
      spawnFood();
      running = true;
      paused = false;
    }

    function spawnFood() {
      while (true) {
        const fx = Math.floor(Math.random() * COLS);
        const fy = Math.floor(Math.random() * ROWS);
        const collision = snake.some(s => s.x === fx && s.y === fy);
        if (!collision) { food = { x: fx, y: fy }; break; }
      }
    }

    function setDirection(x, y) {
      // prevent reversing direction
      if (x === -dir.x && y === -dir.y) return;
      // queue direction to apply on next step
      nextDir = { x, y };
    }

    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w') setDirection(0, -1);
      if (e.key === 'ArrowDown' || e.key === 's') setDirection(0, 1);
      if (e.key === 'ArrowLeft' || e.key === 'a') setDirection(-1, 0);
      if (e.key === 'ArrowRight' || e.key === 'd') setDirection(1, 0);
      if (e.key === ' ' ) togglePause();
    });

    // Touch controls (swipe)
    let touchStart = null;
    canvas.addEventListener('touchstart', (e) => {
      const t = e.changedTouches[0];
      touchStart = { x: t.clientX, y: t.clientY };
      e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      if (!touchStart) return;
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStart.x;
      const dy = t.clientY - touchStart.y;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > 20) setDirection(1,0);
        else if (dx < -20) setDirection(-1,0);
      } else {
        if (dy > 20) setDirection(0,1);
        else if (dy < -20) setDirection(0,-1);
      }
      touchStart = null;
      e.preventDefault();
    }, { passive: false });

    function update() {
      // apply queued direction
      dir = nextDir;

      const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // Wall collision — game over
      if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
        gameOver();
        return;
      }

      // Self collision
      for (let i = 0; i < snake.length; i++) {
        if (head.x === snake[i].x && head.y === snake[i].y) { gameOver(); return; }
      }

      snake.unshift(head);

      // Eating food
      if (head.x === food.x && head.y === food.y) {
        score++;
        scoreEl.textContent = 'Score: ' + score;
        spawnFood();
      } else {
        snake.pop();
      }
    }

    function gameOver() {
      running = false;
      paused = false;
      if (score > high) { high = score; localStorage.setItem('snake_high', high); highEl.textContent = 'High: ' + high; }
      setTimeout(() => {
        alert('Game Over! Score: ' + score);
      }, 10);
    }

    function drawCell(x, y, fillStyle) {
      ctx.fillStyle = fillStyle;
      ctx.fillRect(x * CELL, y * CELL, CELL, CELL);
    }

    function draw() {
      ctx.clearRect(0,0,canvas.width, canvas.height);

      // draw food (circle)
      ctx.beginPath();
      ctx.fillStyle = '#d9534f';
      const fx = food.x * CELL + CELL/2;
      const fy = food.y * CELL + CELL/2;
      ctx.arc(fx, fy, CELL/2 - 2, 0, Math.PI*2);
      ctx.fill();
      ctx.closePath();

      // draw snake
      for (let i = 0; i < snake.length; i++) {
        const p = snake[i];
        if (i === 0) drawCell(p.x, p.y, '#2ca02c'); // head
        else drawCell(p.x, p.y, '#4caf50');
      }

      // grid (optional subtle)
      ctx.strokeStyle = 'rgba(0,0,0,0.03)';
      for (let gx = 1; gx < COLS; gx++) ctx.strokeRect(gx*CELL,0,1,canvas.height);
      for (let gy = 1; gy < ROWS; gy++) ctx.strokeRect(0,gy*CELL,canvas.width,1);
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const delta = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      if (!running || paused) { requestAnimationFrame(loop); return; }

      accumulator += delta;
      while (accumulator >= step) {
        update();
        accumulator -= step;
      }

      draw();
      requestAnimationFrame(loop);
    }

    function togglePause() {
      if (!running) return;
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    }

    startBtn.addEventListener('click', () => {
      if (!running) init();
      lastTime = 0; // reset time so we don't get a huge delta
      requestAnimationFrame(loop);
    });

    pauseBtn.addEventListener('click', () => togglePause());
    restartBtn.addEventListener('click', () => { init(); lastTime = 0; requestAnimationFrame(loop); });

    // initialize but don't start automatically
    init();
    draw();
  </script>
</body>
</html>
